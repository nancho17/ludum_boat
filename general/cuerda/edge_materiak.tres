[gd_resource type="ShaderMaterial" load_steps=4 format=3 uid="uid://c6kgmms5wl1t0"]

[sub_resource type="Shader" id="Shader_yr5qg"]
code = "//---------------------------------------------
// Edge-Detection Shader Pass 2 - Godot 4.4
//
// Here's our fully lit and shaded model,
// but through the screen texture, we also have the world normals
// of all the visible parts of our model that the first pass gives us.
// LICENSE: MIT

shader_type spatial;
render_mode blend_mix, depth_prepass_alpha , cull_back, diffuse_lambert, specular_disabled;

group_uniforms Material;
uniform vec4 albedo : source_color;
uniform sampler2D texture_albedo : source_color;
uniform float specular : hint_range(0.0, 1.0) = 0.5;
uniform float metallic : hint_range(0.0, 1.0) = 0.0;
uniform float roughness : hint_range(0.0, 1.0) = 0.5;

group_uniforms Edge_Detection;
uniform float edge_strength : hint_range(0.0, 1.0) = 0.2;
uniform vec4 edge_color : source_color = vec4(0.5, 0.5, 0.5, 1.0);
uniform sampler2D screen_texture : hint_screen_texture;

// essentially a cheap \"lightness\" function
// returns the average of red, green and blue color channels
float vec3_avg(vec3 color) {
	return (color.r + color.g + color.b) / 3.0;
} 

// transform a pixel coordinate to screen UV
vec2 pixel_to_screen_uv(vec2 viewport_size, vec2 pixel) {
	return vec2(pixel.x / viewport_size.x, pixel.y / viewport_size.y);
}

void fragment() {
	vec4 albedo_tex = texture(texture_albedo, UV);
	
	// Convert screen UV to pixel coordinates
	vec2 pixel_coords = SCREEN_UV * VIEWPORT_SIZE;
	
	// Sample neighboring pixels for edge detection
	vec3 neighbour_left = texture(screen_texture, pixel_to_screen_uv(VIEWPORT_SIZE, pixel_coords + vec2(-1.0, 0.0))).rgb;
	vec3 neighbour_right = texture(screen_texture, pixel_to_screen_uv(VIEWPORT_SIZE, pixel_coords + vec2(1.0, 0.0))).rgb;
	
	vec3 neighbour_top = texture(screen_texture, pixel_to_screen_uv(VIEWPORT_SIZE, pixel_coords + vec2(0.0, -1.0))).rgb;
	vec3 neighbour_bottom = texture(screen_texture, pixel_to_screen_uv(VIEWPORT_SIZE, pixel_coords + vec2(0.0, 1.0))).rgb;
	
	// Base albedo
	ALBEDO = albedo.rgb * albedo_tex.rgb;
	
	// Calculate edge detection gradients
	float horizontal_gradient = abs(vec3_avg(neighbour_left) - vec3_avg(neighbour_right));
	float vertical_gradient = abs(vec3_avg(neighbour_top) - vec3_avg(neighbour_bottom));
	
	// Apply edge detection with threshold
	float edge_threshold = 0.01; // Adjust this value as needed
	if (horizontal_gradient > edge_threshold || vertical_gradient > edge_threshold) {
		ALBEDO = mix(ALBEDO, edge_color.rgb, edge_strength);
	}
	
	METALLIC = metallic;
	ROUGHNESS = roughness;
	SPECULAR = specular;
}
// END OF SHADER PASS 2
//---------------------------------------------"

[sub_resource type="ShaderMaterial" id="ShaderMaterial_2dfbl"]
render_priority = 0
shader = SubResource("Shader_yr5qg")
shader_parameter/albedo = Color(0.48, 0.48, 0.48, 1)
shader_parameter/specular = 0.5
shader_parameter/metallic = 0.0
shader_parameter/roughness = 0.5
shader_parameter/edge_strength = 0.2
shader_parameter/edge_color = Color(0.2337, 0.43548, 0.57, 1)

[sub_resource type="Shader" id="Shader_ryl0k"]
code = "//---------------------------------------------
// Edge-Detection Shader Pass 1
//
// Here we simply pass the vertex normals to the albedo
// so we can access it through the SCREEN_TEXTURE in our Shader Pass 2
// LICENSE: MIT

shader_type spatial;
render_mode blend_mix,depth_draw_opaque,cull_back,diffuse_toon,specular_disabled,shadows_disabled;

varying vec3 world_normal;

void vertex() {
	world_normal = NORMAL;
}

void fragment() {
	ALBEDO = world_normal.rgb;
}

// END OF SHADER PASS 1
//---------------------------------------------"

[resource]
render_priority = 0
next_pass = SubResource("ShaderMaterial_2dfbl")
shader = SubResource("Shader_ryl0k")
